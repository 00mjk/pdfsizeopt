% by pts@fazekas.hu at Sat Jul 11 12:01:05 CEST 2009

\documentclass{article}
%\usepackage[latin2]{inputenc}% !! check
\usepackage{t1enc}
\usepackage{lmodern}
\usepackage[english]{babel}

\def\cmd{\textsf}
\def\pkg{\textsf}


\begin{document}

\section{What is PDF?}

PDF is a popular document file format designed for printing and on-screen
viewing. PDF faithfully preserves the design elements of the document, such
as fonts, line breaks, page breaks, exact spacing, text layout, vector
graphics and image resolution. Thus the author of a PDF document has precise
control over the document's appearance -- no matter what operating system or
renderer software is used for viewing or printing the PDF. From the viewer's
prespecive, a PDF document is a sequence of rectangular pages containing
text, vector graphics and pixel-based images. In addition to that, some
rectangular page regions can be marked as hyperlinks, and Unicode
annotations can be added as well to the regions, so text can be copy-pasted
from the documents. (Usually the copy-paste yields only a sequence of
characters, with all formatting and positioning lost. Depending on the
software and the annotation, the bold and italics properties can be
preserved.) A table of contents can be added as well, which has a tree
structure, and each node of the tree consists of an unformatted caption and
a hyperlink within the document.

Additional features of PDF include forms (the user fills some fields with
data, clicks on the submit button, and the data is sent to a server in an
HTTP request), event handlers in JavaScript, embedded multimedia files,
encryption and access protection.

\section{How to create PDF}

Since PDF doesn't contain semantic information about the document (such as
in which order the document should be read, which regions are titles, how
are the tables built and how are the charts generated), word processors and
typesetting systems usually can export to PDF, but they have their own file
format which preserves semantics. PDF is usually not involved while the
author is composing (or typeseting) the document, but once a version of a
document is ready, a PDF can be exported and distributed. Should the author
distribute the document in the native file format of the word processor, he
might risk that the document doesn't get rendered as he intended, due to
software version differences or because slightly different fonts are
installed on the rendering computer, or the page layout settings in the word
processor are different.

Most word processors and drawing programs and image editors support
exporting as PDF. It is also possible to generate a PDF even if the software
doesn't have a PDF export feature. For example, it may be possible to
install a printer driver, which generates PDF instead of sending the
document to a real printer. (For example, on Windows, PDFCreator
\cite{pdfcreator} is such an open-source driver.) Some old programs can emit
PostScript, but not PDF. The \cmd{ps2pdf} \cite{ps2df} tool (part of
Ghostcript) can be used to convert the PostScript to PDF.

For \TeX{} documents there are several options for PDF generation. One
traditional approach is \TeX{} source $\to$ DVI $\to$ PostScript $\to$ PDF,
using \cmd{dvips} \cite{dvips} for creating the PostScript file, and
\cmd{ps2pdf} for creating the PDF file. One can convert directly from DVI to
PDF, using e.g.\ \cmd{dvipdfm} \cite{dvipdfm}. The single-step approach is
processing the \TeX{} source with pdf\TeX{} \cite{pdftex}, which generates
PDF without any intermediate files. We recommend using pdf\TeX{} whenever
possible, because it creates a small PDF file, it is fast, and it supports
the most PDF features without compromises. For example, the other approaches
cannot break the line in the middle of a hyperlink, but pdf\TeX{} can even
hyphenate the link text automatically.

Unfortunately, some graphics packages (such as \pkg{psfrag} and
\pkg{pstricks}) require a PostScript backend, and pdf\TeX{} doesn't provide
that. We recommend typesetting new graphics with TikZ \cite{tikz} if possible
(which fully supports pdf\TeX{}), and converting other graphics to PDF,
possibly typesetting label captions using \TeX{}, as outlined in
\cite{psfrag-in-pdf}. Inkscape users can use \pkg{textext} \cite{textext}
within Inkscape to make \TeX{} typeset the captions.

With pdf\TeX{}, it is possible to reuse existing PDF files by embedding
parts of them to the document. The \texttt{\string\includegraphics} command
of the standard \pkg{graphicx} \LaTeX{}-package accept a PDF as the image
file. In this case, the first page of the specified PDF will be used as a
rectangular image. For multi-page inclusions, the \pkg{pdfpages}
\LaTeX{}-package can be used. Please note that due to a limitation in
pdf\TeX{}, hyperlinks and outlines (table of contents) in the embedded PDF
will be lost.

\section{Motivation}

Our goal is to reduce the file size of PDF documents, focusing on PDF files
created from \TeX{} documents. Having smaller PDF files reduces download
times, web hosting costs and storage costs as well. Although there is no
urgent need for reducing PDF storage costs is for personal use (since hard
drives in modern PCs are large enough), storage costs are significant for
publishing houses, print shops, e-book stores and hosting services,
libraries and archives \cite{multivalent-article}.
Usually lots of copies and backups are made of PDF
files originating from such places, saving 20\% of the file size right after
generating the PDF would save 20\% of all future costs associated with the
file.

Although e-book readers can store lots of documents (e.g.\ a 4\,GB e-book
reader can store 800 PDF books of 5\,MB average reasonable file size), they
get full quickly if we don't pay attention to efficient PDF generation. One
can easily get a PDF file 5 times larger than reasonable by using
inefficient software to generate it, or not setting the export settings
properly. Upgrading or changing the generator software is not always
feasible. A PDF recompressor becomes useful in these cases.

It is not our goal to propose or use
alternative file formats, which support a more
compact document representation or more agressive compression than PDF. An
example for such an approach is the Multivalent \emph{compact} file format
\cite{multivalent-compact}, which can be generated from a PDF using the
Multivalent tools, and it can be converted back to a regular PDF with these
tools as well. One of the merits of PDF is that it has a definitive, widely
accepted and implemented, freely available
specification \cite{pdfref} (and version 1.7 is
even ISO standard \cite{pdf-iso}), so if 20 years later we want to
print the document we've create today, then a well-documented and
standardized format such as PDF is a natural choice. (Please note, however,
that the PDF specification is not self-contained, it refers to other
specifications, e.g.\ for some compression algorithms and font formats.)
Another alternative document format is is DjVu (see in Section
\ref{related-work}).

It is possible to save space in a PDF by removing non-printed information
such as hyperlinks, document outline elements, forms, text-to-Unicode
mapping or user annotations. Removing these does not affect the output when
the PDF is printed, but it degrades the user experience when the PDF is
viewed on a computer, and it may also degrade navigation and searchability.
Another option is to remove (unembed fonts). In such a case, the PDF viewer
will pick a font with similar metrics if the font is not installed on the
viewer machine. Please note that unembedding the font doesn't change the
horizontal distance between glyphs, so the page layout will remain the
same, but maybe glpyhs will look funny or hard-to-read. Yet another option
to save space is to reduce the resolution of the embedded images. We will
not use any of the techniques mentioned in this paragraph, because our goal
is to reduce redundancy and make the byte representation more effective,
while preserving visual and semantic information in the document.

\section{PDF file structure}

It is possible to save space in the PDF by serializing the same information
more efficiently and/or using better compression. This section gives a
high-level introductions to the data structures and their serialization in
the PDF file, focusing on size optimization. For a full description of the
PDF file format, see \cite{pdfref}.

PDF supports integer, real number, boolean, null, string and name as
simple data types. A string a sequence of 8-bit bytes. A name is also a
sequence of 8-bit bytes, usually a concatenation of a few English words in
CamelCase, often used as a dictionary key (e.g. \texttt{/MediaBox}) or an
enumeration value (e.g. \texttt{/DeviceGray}). Composite data types are the
list and the dictionary. A dictionary is an unordered sequence of key--value
pairs, where keys must be names. Values in dictionaries and list items can
be primitive or composite. There is a simple serialization of values to
8-bit strings, compatible with PostScript LanguageLevel\,2. For example,
\texttt{\hbox{<}</Integer 5 /Real -6.7 /String ((C)2009\textbackslash))
/StringInHex <Face> /Null null
/Boolean true /Name /Foo /List [3 4 5]\hbox{>}>} defines a dictionary
containing values of various types. All data types are immutable.

It is possible to define a value for future use by defining an
\emph{object.} For example, \texttt{12 0 obj [/PDF/Text] endobj} defines
object number 12 to be an array of two items (\texttt{/PDF} and
\texttt{/Text}). The number 0 in the definition is the so-called generation
number, referring to version of the incrementally updated PDF file this
object was created in. Since most of the tools just create a new PDF instead
of updating parts of an existing one, we can assumme for simplicity that the
generation number is always zero. Once an object is defined it is possible
to refer to it (e.g.\ \texttt{12 0 R}) instead of typing its value. It is
possible to define self-referential lists and dictionaries using object
definitions. The PDF specification requires some PDF structure elements
(such as the \texttt{/FontDescriptor} value) be an indindirect reference,
i.e.\ defined as an object. Such elements cannot be inlined into other
object, but they must be referred to.

A PDF file contains a header, a list of objects, a \emph{trailer}
dictionary, cross-reference information (offsets of object definitions,
sorted by object number), and the end-of-file marker. The header contains
the PDF version (PDF-1.7 being the latest). All of the file elements above
except for the PDF version, the list of objects and the trailer are
redundant, and can be regegenerated if lost. The parsing of the PDF starts
at the trailer dictionary. Its \texttt{/Root} value refers to the catalog
dictionary object, whose \texttt{/Pages} value refers to a dictionary object
containing the list of pages. The interpretation of each object depends on
the reference path which leads to that object from the trailer. In addition
to that, dicitionary objects may have the \texttt{/Type} and/or
\texttt{/Subtype} value indicating the interpretation. For example,
\texttt{\hbox{<}</Subtype/Image ...\hbox{>}>} defines a pixel-based image.

In addition to the data types above, PDF supports streams as well. A
\emph{stream} object is a dictionary augmented by the stream data, which is
a byte sequence. The syntax is \texttt{... ... obj << ... >> stream ...
endstream endobj}, where the stream data starts right after the keyword
\texttt{stream}. The stream data can be compressed or otherwise encoded
(such as in hex). The \texttt{/Filter} and \texttt{/DecodeParms} values in
the dictionary specify how the uncompress/\allowbreak decode the stream data.
It possible the specify multiple uncompress/\allowbreak decode filters,
e.g.\ \texttt{/Filter [/ASCIIHexDecode /FlateDecode]} says that the bytes
aftter \texttt{stream} should be decoded as a hex string, and then
uncompressed using PDF's ZIP implementation. (Please note that the use of
\texttt{/ASCIIHexDecode} is just a waste of space unless one wants to create
an ASCII PDF file.) The three most common uses for
streams are: image pixel data, embedded font files and content streams.
A content stream contains the instructions to draw the contents of page. The
stream data is ASCII, with a syntax similar to PostScript, but with
different operators. For example, \texttt{BT/F 20 Tf 1 0 0 1 8 9
Tm(Hello world)Tj ET} in a content stream draws the text ``Hello World''
with the font \texttt{/F} at size 20 units, shifted up by 8 units, and
shifted right by 9 units (according to the transformation matrix
\texttt{1 0 0 1 8 9}).

Streams can use the following generic compression methods: ZIP (also called
as flate), LZW and run-length encoding. ZIP is almost always superior. In
addition to those, PDF supports some image-specific compression methods as
well: JPEG and JPEG2000 for true-color images and JBIG2 and G3 fax (also
called as CCITT fax) for bilevel (two-color) images. JPEG and JPEG2000 are
lossy methods, they usually yield the same size at the same quality
settings -- but JPEG2000 is more flexible. JBIG2 is superior to G3 fax and
ZIP for bilevel images. Any number of compression filters can be applied to
a stream, but usually applying more than one yields a larger compressed
stream size than just applying one. ZIP and LZW support predicors as well. A
predictor is an easy-to-compute, invertible filter which is applied to the
stream data before compression, to make the data more compressible. One
possible predictor subtracts the previous data value from the current one,
and sends the difference to the compressor. This helps reducing the file
size if the difference between adjacent data values is small most of the
time. This is true for some images with a few number of colors.

There is cross-reference information near the end of the PDF file, which
contains the start byte offset of all object definitions. Using this
information it is possible to render parts of the file, without reading the
whole file. The most common format for cross-reference information is the
\emph{cross-reference table} (starting with the keyword \texttt{xref}). Each item
in the table consumes 20 bytes, and contains an object byte offset. The
object number is encoded by the position of the item. For PDFs with several
thousand objects, the space occupied by the cross-reference table is is not
negligable. PDF\,1.5 introduces \emph{cross-reference streams,} which store
the cross-reference information in compact form in a stream. Such streams
usually compressed as well, using ZIP and a predictor. The benefit of the
predictor is that adjacent offsets are close to each other, so their
difference will contain lots of zeroes, which can be compressed efficiently.

Compression cannot be applied to the PDF file as a whole, only individual
parts (such as stream data and cross-reference information) can be
compressed. However, there can be lots of small object definitions in the
file which are not streams. To compress those, PDF\,1.5 introduces
\emph{object streams.} The data in an object stream contains a concatenation
of any number of non-stream object definitions. Object streams can be
compressed just as regular stream data. This makes it possible to eliminate
repetitions spanning over multiple object definitions. Thus, with PDF\,1.5,
most of the PDF file can be stored in compressed streams. Only a few dozen
byte of headers and end-of-file markers, and the stream dictionaries remain
uncompressed.

\section{How to save space in a PDF}

!! give details
!! who implements what
!! what is new work in pdfsizeopt.py
!! what does pdflatex and dvipdfm implement

\paragraph{Use cross-reference streams}

\paragraph{Use object streams}

\paragraph{Use better stream compression}

\paragraph{Recompress images}

\paragraph{Eliminate duplicate objects}

\paragraph{Reorganize content streams}

\paragraph{Eliminate unnecessary indirect references}

\paragraph{Eliminate duplicate images, based on pixel value}

\paragraph{Convert Type\,1 fonts to CFF}

\paragraph{Unify font subsets}

\paragraph{Remove data ignored by the PDF specification}

\paragraph{Omit explicitly specified default values}

\paragraph{Convert hex strings to binary}

\paragraph{Escape only if necessary in strings}

\paragraph{Eliminate unused objects}

\paragraph{Eliminate page thumbnails}

\paragraph{Subset fonts}

\paragraph{Unify subsets of the same font}

\paragraph{Convert some inline images to objects}


\section{!! TODO}

!! dvipdfm with different fontconfig
!! pdftex and cross-reference streams (buggy)
!! ASCII-repr string hex shorter
!! ASCIIHexDecode shorter
!! why is content stream compression good?

!! base 14: cp `kpsewhich pdftex\_ndl14.map` pdftex.map
pdftexDownloadBase14 false in updmap.cfg

!! dvipdfm creates a bit smaller PDF than pdftex

\section{Related work}\label{related-work}

An alternative document file format is DjVu (\cite{djvu,djvu-tutorial}),
whose most important limitation compared to PDF is that it doesn't support
vector graphics. Due to the sophisticated image layer separation and
compression, the size of a 600\,DPI DjVu file is comparable to the
coressponding optimized PDF document. If the PDF contains maily images (such
as a sequence of scanned sheets), the DjVu file will become slightly smaller
than the PDF file. If the PDF contains text with embedded vector fonts and
vector graphics, the DjVu file can be about 3 times larger than the PDF.
Of course these ratios depend on the software used for encoding as well.
There are only a few DjVu encoders available: \cmd{pdf2djvu} and
\cmd{djvudigital} are free, and Document\,Express is a commercial
application.

Since the DjVu file format uses very different technologies than PDF, one
can archive both the PDF and the DjVu version of the same document, in case
a decent renderer won't be available for one of the formats decades later.

!! more related work

\section{References}

!! \cite all

!! \cite the PDF optimization article and all from info.txt

@psfrag-in-pdf{
  url=http://brunoj.wordpress.com/2007/07/12/producing-high-quality-eps-and-pdf-diagrams-for-mathematics/
}

@iso-pdf{
PDF 1.7 is ISO 32000
meta-link: http://www.theinquirer.net/inquirer/news/1030411/pdf-approved-iso-32000
}

@djvu-tutorial{
http://www.djvuzone.org/support/tutorial/chapter-intro.html
}

\end{document}
